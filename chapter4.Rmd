#Clustering and Classification
The list of materials and links related to clustering and classification can be found below.  
[course slides by Emma Kämäräinen](https://tuomonieminen.github.io/Helsinki-Open-Data-Science/#/41)  
[DataCamp exercise](https://campus.datacamp.com/courses/helsinki-open-data-science/clustering-and-classification?ex=1)

##RStudio Exercise 4
After solving the DataCamp exercise and going through the embedded links, I got a general overview on the topic. In the following sections, I will prepare a report based on the exercise instructions. Unlike earlier weeks, the data wrangling exercise will be done after the data analysis part. In fact, the data wrangling exercise is part of [Dimensionality Reduction Techniques](https://kisun.github.io/IODS-project/#dimensionality-reduction-techniques). In the following section, I will explain about clustering and classification of data sets using open data called Boston that belongs to [MASS package](https://cran.r-project.org/web/packages/MASS/index.html).

**Data**  

First and foremost, it is important to get an overview of the data being analysed. As mentioned earlier, Boston data from [MASS package](https://cran.r-project.org/web/packages/MASS/index.html). 
```{r ex2}
library(MASS)
data(Boston)
str(Boston)
dim(Boston)
```
The **Boston** data was collected to study the housing values in the suburbs of Boston. The table contains 506 observations for 14 different variables. The descriptions for each of the 14 variables are listed below.

Variables | Description
--------- | -----------------------------------------------------------------
crim | per capita crime rate by town.
zn | proportion of residential land zoned for lots over 25,000 sq.ft.
indus | proportion of non-retail business acres per town.
chas | Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
nox | nitrogen oxides concentration (parts per 10 million).
rm | average number of rooms per dwelling.
age | proportion of owner-occupied units built prior to 1940.
dis | weighted mean of distances to five Boston employment centres.
rad | index of accessibility to radial highways.
tax | full-value property-tax rate per \$10,000.
ptratio | pupil-teacher ratio by town.
black | 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
lstat | lower status of the population (percent).
medv | median value of owner-occupied homes in \$1000s.

**Data Summary**  

Now, let's look at the summary of the boston data in the form of table (instead of default layout) using *pandoc.table* function of **pander** package. 
```{r ex3.1}
library(pander)
pandoc.table(summary(Boston), caption = "Summary of Boston data", split.table = 120)
```

After getting a statistical summary of, it's worthwhile to see to what extent each variables are correlated. For that, we use **corr()** function on Boston data. 

```{r, ex3.2, fig.width=9, fig.height=9}
library(corrplot)
library(dplyr)
corr_boston<-cor(Boston) %>% round(2)
pandoc.table(corr_boston, split.table = 120)
```

The table above shows the correlation matrix of all variables. Bird's eye view on the matrix shows that **tax** (full-value property-tax rate) and **rad** (index of accessibility to radial highways) are the most positively correlated variables, whereas **dis** (weighted mean of distances to five Boston employment centres) and **age** (proportion of owner-occupied units built prior to 1940) are the most negatively correlated variables. Moreover, **chas** (Charles river dummy variable) and **rad** are the two variables that are least correlated.

The same information can be presented as a graphical overview. This time we will make a correlogram, a graphical representation of coorelation matrix. The *corrplot()* function of **corrplot** package wll be used to visualize the correlation between all the variables of the Boston dataset.
```{r}
corrplot(corr_boston, method = "circle", tl.col = "black", cl.pos="b", tl.pos = "d", type = "upper" , tl.cex = 0.9 )
```

The above graph gives much quicker impression on which variables are more correlated to each other. In the graph, positive correlations are displayed in blue and negative correlations in red color with intensity of the color and circle size being proportional to the correlation coefficients. The same relationship as described above using correlation summary can be seen in the form of circles with different size (intensity of correlation i.e highly correlated or lowly correlated) and different colors (wheether positively or negatively correlated).


**Data Standardization**  

Data scaling is useful for linear discriminant analysis. The **scale()** function will be used to scale the whole data. Here, the scaled value is generated by subtracting the column means from corresponding columns and then the difference is divided by standard deviation. i.e scaled(x)=(x-mean(x))/sd(x). 
```{r ex_4.1}
boston_scaled<-scale(Boston)
pandoc.table(summary(boston_scaled), caption = "Summary of  Scaled Boston data", split.table = 120)
#corr_bostons<-cor(boston_scaled) %>% round(2)
#pandoc.table(corr_bostons, split.table = 120)
```

We can make important observations on the summary of scaled data. The summary of the scaled Boston data has changed from the non-scaled Boston data. Most importantly, all the mean values have become zero and other values such as minimum, maximum, median and quartiles (1st and 3rd) are also changed for all variables. 

Next, we will create quantile vector for crime using **quantile** function on scaled dataframe of Boston dataset. The quantile vectors will be labeled with meaningful labels to explain the intensity of crime i.e low, medium low, medium high and high. Lastly, we will replace the **Crim** variable with newly created **crime** variable and create the required data frame.

```{r, ex_4.2}
boston_scaled<- data.frame(boston_scaled)
qvc<-quantile(boston_scaled$crim)
crime <- cut(boston_scaled$crim, breaks = qvc, label = c("low", "med_low", "med_high", "high"), include.lowest = TRUE)
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled<-data.frame(boston_scaled, crime)
#table(boston_scaled$crime)
```
After creating the customized dataset in earlier steps, we will now divide it into training and testing sets where 80% of the data will belong to training set and 20% will be used as testing set.
```{r, ex_4.3}
#library(MASS)
n<-nrow(boston_scaled)
ind <- sample(n, size = n*0.8)
train <- boston_scaled[ind,]
test <- boston_scaled[-ind,]
```

Now, as we have categorized the dataset into training and test set, we can fit linear discriminant analysis on the training set, where crime rate will be predicated based on all other variables.  

**Linear Discriminant Analysis**  

```{r ex_5, fig.height=8, fig.width=12}
lda.fit <- lda(crime ~ ., data = train)
#add biplot arrows to an lda
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
  heads <- coef(x)
  arrows(x0 = 0, y0 = 0, 
         x1 = myscale * heads[,choices[1]], 
         y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
  text(myscale * heads[,choices], labels = row.names(heads), 
       cex = tex, col=color, pos=3)
}

classes <- as.numeric(train$crime)

# plot the lda results
plot(lda.fit, dimen = 2, col=classes)
lda.arrows(lda.fit, myscale = 2)
# target classes as numeric
#classes <- as.numeric(train$crime)

# plot the lda results
#plot(lda.fit, dimen = 2, col = classes, pch = classes)
```
Based on the bi-plot, it can be seen that **rad** variable alone acts as a predictor of high crime rate in the Boston data. On the other hand, the remaining 12 variables are associated with low, medium low and medium high rate of crime. The grouping based on 12 variables is fuzzy and is difficult to classify if any of the variables can classify the associated observations.


**Class Prediction**

```{r, ex_6}
crime_cat<-test$crime
test<-dplyr::select(test, -crime)
lda.pred<-predict(lda.fit, newdata = test)
table(correct = crime_cat, predicted = lda.pred$class)

```
I tried to grasp the concept of the above matrix, which is also referred to as confusion matrix going through [this blog](https://machinelearningmastery.com/confusion-matrix-machine-learning/). Everytime the matrix is generated, the number of correct and predicted cases for each of the classes (low, med_low, med_high, high) changes. The change is expected because of the randomized classification of test and training set. However, it was also observed that prediction for the high class fluctuated much lesser than the other classes. 


**K-means Clustering**

In order to practice K-means clustering, we will reload the Boston data, scale the data and calculate the distances between the observations. 

```{r, ex_7.1}
data(Boston)
boston_scaled1<-as.data.frame(scale(Boston))
dist_eu<-dist(boston_scaled1)
summary(dist_eu)
#head(boston_scaled1)
```
We will use the scaled Boston data to perform K-means clustering. It's always not trivial beforehand to identify how many clusters can classify our data. Therefore, we need to first randomly use certain number of clusters (if we can get any idea from the summary of the data or graphical summaries) but there are few other ways we can identify right number of clusters. This topics is more or less inspired by [this R-blogger post](https://www.r-bloggers.com/finding-optimal-number-of-clusters/) and [this Stackoverflow question](https://stackoverflow.com/questions/15376075/cluster-analysis-in-r-determine-the-optimal-number-of-clusters)


First we start with random cluster number. Let's start with k=4 and apply k-means on the data.
```{r}
#Let us apply kmeans for k=4 clusters 
kmm = kmeans(boston_scaled1,6,nstart = 50 ,iter.max = 15) #we keep number of iter.max=15 to ensure the algorithm converges and nstart=50 to ensure that atleat 50 random sets are choosen  
```

Elbow method is also one of the well known techniques that can be used to estimate number of clusters.
```{r ex7.2}
#Elbow Method for finding the optimal number of clusters
library(ggplot2)
set.seed(1234)
# Compute and plot wss for k = 2 to k = 15.
k.max <- 15
data <- boston_scaled1
wss <- sapply(1:k.max, 
              function(k){kmeans(data, k)$tot.withinss})
#wss
qplot(1:k.max, wss, geom = c("point", "line"), span = 0.2,
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```
  
Somehow the elbow plot shows that we may not see more than two clear clusters but it's always nice to confirm such predictions using one more method because there is not shortage of methods for a number of analyses such as this. Therefore, we will additionally use **NbClust** package.
```{r, ex_7.3}
library(NbClust)
nb <- NbClust(boston_scaled1, diss=NULL, distance = "euclidean", 
              min.nc=2, max.nc=5, method = "kmeans", 
              index = "all", alphaBeale = 0.1)
#hist(nb$Best.nc[1,], breaks = max(na.omit(nb$Best.nc[1,])))

```
Now, it's much clearer that the data is described better with two clusters. With that, we run k-means algorithm again. 


```{r, ex7.4, fig.height=10, fig.width=10}
#Let us apply kmeans for k=4 clusters 
km_final = kmeans(boston_scaled1, centers = 2) #we keep number of iter.max=15 to ensure the algorithm converges and nstart=50 to ensure that atleat 50 random sets are choosen  
pairs(boston_scaled1[3:9], col=km_final$cluster)

```


The clusters in the above plot are divided into two groups and represented by two colors - red and black. Some of the pairs are better grouped than others in the plot. One of the important observations can be made with **chas** variable where the observations in all the pairs formed by it are wrongly clustered. On the other hand, clusters formed by **rad** variable are better separated.


**More LDA**  
In the following section, we will use random cluster number (k=6) and perform LDA. We follow the the basic steps of scaling and distance calculation. Finally we will see how the biplot looks like on the whole data set when we try to group them into six categories.

```{r, bonus}
boston_scaled2<-as.data.frame(scale(Boston))
head(boston_scaled2)
set.seed(1234)
km_bs2<-kmeans(dist_eu, centers = 6)
#head(km_bs2)
myclust<-data.frame(km_bs2$cluster)
boston_scaled2$clust<-km_bs2$cluster
head(boston_scaled2)
lda.fit_bs2<-lda(clust~., data = boston_scaled2 )
lda.fit_bs2

# the function for lda biplot arrows
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
  heads <- coef(x)
  arrows(x0 = 0, y0 = 0, 
         x1 = myscale * heads[,choices[1]], 
         y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
  text(myscale * heads[,choices], labels = row.names(heads), 
       cex = tex, col=color, pos=3)
}
plot(lda.fit_bs2, dimen = 2)
lda.arrows(lda.fit_bs2, myscale = 3)

```
  
I must admit that the number of clusters I chose was more than needed. I believe three to four clusters could group the whole data set. The top three most influential variables according to bi-plot are **zn**, **nox** and **tax**.  

**Better ways to visualize LDA**
```{r, superbonus, fig.width=8, fig.height=8}
library(plotly)
model_predictors <- dplyr::select(train, -crime)
# check the dimensions
dim(model_predictors)
dim(lda.fit$scaling)
# matrix multiplication
matrix_product <- as.matrix(model_predictors) %*% lda.fit$scaling
matrix_product <- as.data.frame(matrix_product)
plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type= 'scatter3d', mode='markers', color = train$crim)
```

```{r superbonus.1, fig.width=8, fig.height=8}
#Second 3D plot where colors are defined by clusters of k-means
#k-means_matpro<-kmeans(matrix_product, )
#head(train)
#train$cl<-myclust
#boston_scaled2$cl<-myclust
#head(boston_scaled2)
#head(train)
#rownames(train)
#rownames(boston_scaled2)
train$cl <- boston_scaled2$clust[match(rownames(train), rownames(boston_scaled2))]
#head(train)
#nrow(train)

plot_ly(x = matrix_product$LD1, y = matrix_product$LD2, z = matrix_product$LD3, type = "scatter3d", mode="markers", color = train$cl)

```
According to my observation, clustering based on K-means have turned out to be more informative than the one based on crime classes. 

**Additional links (also included in the course slides)**  
[Blog post by Jason Browniee on LDA](https://machinelearningmastery.com/linear-discriminant-analysis-for-machine-learning/)  
[R-bloggers post on LDA](https://www.r-bloggers.com/computing-and-visualizing-lda-in-r/)
[R-bloggers post on K Means Clustering in R](https://www.r-bloggers.com/k-means-clustering-in-r/)
